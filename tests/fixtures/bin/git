#!/bin/sh
# tests/fixtures/bin/git — deterministic git stub for E2E tests
#
# Supports the subcommands that Gitflow invokes. Returns canned output
# for each supported command and exits non-zero for unknown commands.
# Set GITFLOW_GIT_LOG to a file path to record all invocations.
# Set GITFLOW_GIT_FAIL=<subcommand> to force that subcommand to fail.
set -eu

if [ -n "${GITFLOW_GIT_LOG:-}" ]; then
  printf '%s\n' "$*" >> "$GITFLOW_GIT_LOG"
fi

# Allow forcing failure for any subcommand
fail_cmd="${GITFLOW_GIT_FAIL:-}"

subcmd="${1:-}"
shift 2>/dev/null || true

case "$subcmd" in

  # ── status ────────────────────────────────────────────────────────────
  status)
    if [ "$fail_cmd" = "status" ]; then
      echo "fatal: not a git repository" >&2
      exit 128
    fi
    case " $* " in
      *" --porcelain=v2 "*|*" --porcelain=2 "*)
        # porcelain v2 records
        printf '# branch.oid abc1234567890abcdef1234567890abcdef1234\n'
        printf '# branch.head main\n'
        printf '1 .M N... 100644 100644 100644 abc1234 abc1234 tracked.txt\n'
        printf '? new.txt\n'
        ;;
      *)
        # porcelain v1 records
        printf ' M tracked.txt\n'
        printf '?? new.txt\n'
        ;;
    esac
    ;;

  # ── branch ────────────────────────────────────────────────────────────
  branch)
    if [ "$fail_cmd" = "branch" ]; then
      echo "fatal: branch failed" >&2
      exit 1
    fi
    # Check for format flag (used by panels/branch.lua)
    case "$*" in
      *--format*)
        printf 'main\n'
        printf 'feature/test\n'
        printf 'bugfix/login\n'
        ;;
      *)
        printf '* main\n'
        printf '  feature/test\n'
        printf '  bugfix/login\n'
        ;;
    esac
    ;;

  # ── diff ──────────────────────────────────────────────────────────────
  diff)
    if [ "$fail_cmd" = "diff" ]; then
      echo "fatal: diff failed" >&2
      exit 1
    fi
    case "$*" in
      *--name-only*--diff-filter=U*)
        # conflict list: return conflicted file paths
        if [ -n "${GITFLOW_GIT_CONFLICTS:-}" ]; then
          printf '%s\n' "$GITFLOW_GIT_CONFLICTS"
        fi
        ;;
      *)
        cat <<'DIFF'
diff --git a/tracked.txt b/tracked.txt
index 1234567..abcdefg 100644
--- a/tracked.txt
+++ b/tracked.txt
@@ -1,2 +1,3 @@
 alpha
 beta
+gamma
DIFF
        ;;
    esac
    ;;

  # ── log ───────────────────────────────────────────────────────────────
  log)
    if [ "$fail_cmd" = "log" ]; then
      echo "fatal: log failed" >&2
      exit 1
    fi
    case " $* " in
      *" --pretty=format:"*)
        # parser-compatible shape for gitflow.git.log.parse():
        # <full_sha><TAB><summary>
        printf 'abc1234567890abcdef1234567890abcdef1234\tabc1234 Initial commit\n'
        printf 'def5678901234abcdef1234567890abcdef5678\tdef5678 Add feature\n'
        printf 'fed9012345678abcdef1234567890abcdef9012\tfed9012 Fix bug\n'
        ;;
      *)
        printf 'abc1234 Initial commit\n'
        printf 'def5678 Add feature\n'
        printf 'ghi9012 Fix bug\n'
        ;;
    esac
    ;;

  # ── checkout ──────────────────────────────────────────────────────────
  checkout)
    if [ "$fail_cmd" = "checkout" ]; then
      echo "error: checkout failed" >&2
      exit 1
    fi
    printf "Switched to branch '%s'\n" "${1:-main}"
    ;;

  # ── merge ─────────────────────────────────────────────────────────────
  merge)
    if [ "$fail_cmd" = "merge" ]; then
      echo "CONFLICT (content): Merge conflict in file.txt" >&2
      exit 1
    fi
    case "$1" in
      --continue)
        printf 'merge --continue completed\n'
        ;;
      --abort)
        printf 'merge --abort completed\n'
        ;;
      *)
        printf 'Already up to date.\n'
        ;;
    esac
    ;;

  # ── rev-parse ─────────────────────────────────────────────────────────
  rev-parse)
    if [ "$fail_cmd" = "rev-parse" ]; then
      echo "fatal: rev-parse failed" >&2
      exit 128
    fi
    case "$*" in
      *--show-toplevel*)
        pwd
        ;;
      *--git-dir*)
        printf '%s/.git\n' "$(pwd)"
        ;;
      *--abbrev-ref*@\{upstream\}*|*--symbolic-full-name*@\{upstream\}*)
        printf 'origin/main\n'
        ;;
      *--abbrev-ref*)
        printf 'main\n'
        ;;
      *)
        printf 'abc1234567890\n'
        ;;
    esac
    ;;

  # ── stash ─────────────────────────────────────────────────────────────
  stash)
    if [ "$fail_cmd" = "stash" ]; then
      echo "error: stash failed" >&2
      exit 1
    fi
    stash_sub="${1:-list}"
    shift 2>/dev/null || true
    case "$stash_sub" in
      list)
        printf 'stash@{0}: WIP on main: abc1234 Initial commit\n'
        printf 'stash@{1}: On main: save work\n'
        ;;
      push)
        printf 'Saved working directory and index state WIP on main\n'
        ;;
      pop)
        printf 'Dropped refs/stash@{0}\n'
        ;;
      drop)
        printf 'Dropped refs/stash@{0}\n'
        ;;
    esac
    ;;

  # ── push ──────────────────────────────────────────────────────────────
  push)
    if [ "$fail_cmd" = "push" ]; then
      echo "error: push failed" >&2
      exit 1
    fi
    printf 'Everything up-to-date\n'
    ;;

  # ── pull ──────────────────────────────────────────────────────────────
  pull)
    if [ "$fail_cmd" = "pull" ]; then
      echo "error: pull failed" >&2
      exit 1
    fi
    printf 'Already up to date.\n'
    ;;

  # ── fetch ─────────────────────────────────────────────────────────────
  fetch)
    if [ "$fail_cmd" = "fetch" ]; then
      echo "error: fetch failed" >&2
      exit 1
    fi
    # fetch produces no stdout on success
    ;;

  # ── rebase ────────────────────────────────────────────────────────────
  rebase)
    if [ "$fail_cmd" = "rebase" ]; then
      echo "CONFLICT (content): Merge conflict in file.txt" >&2
      exit 1
    fi
    case "$1" in
      --continue)
        printf 'rebase --continue completed\n'
        ;;
      --abort)
        printf 'rebase --abort completed\n'
        ;;
      *)
        printf 'Current branch main is up to date.\n'
        ;;
    esac
    ;;

  # ── cherry-pick ───────────────────────────────────────────────────────
  cherry-pick)
    if [ "$fail_cmd" = "cherry-pick" ]; then
      echo "error: cherry-pick failed" >&2
      exit 1
    fi
    case "$1" in
      --continue)
        printf 'cherry-pick --continue completed\n'
        ;;
      --abort)
        printf 'cherry-pick --abort completed\n'
        ;;
      *)
        printf '[main abc1234] Cherry-picked commit\n'
        ;;
    esac
    ;;

  # ── add ───────────────────────────────────────────────────────────────
  add)
    if [ "$fail_cmd" = "add" ]; then
      echo "fatal: add failed" >&2
      exit 1
    fi
    # add produces no stdout on success
    ;;

  # ── reset ─────────────────────────────────────────────────────────────
  reset)
    if [ "$fail_cmd" = "reset" ]; then
      echo "fatal: reset failed" >&2
      exit 1
    fi
    printf 'Unstaged changes after reset:\n'
    ;;

  # ── show ──────────────────────────────────────────────────────────────
  show)
    if [ "$fail_cmd" = "show" ]; then
      echo "fatal: show failed" >&2
      exit 1
    fi
    case "$1" in
      :1:*)
        # base version of conflicted file
        printf 'line one\nline two\nbase content\nline four\n'
        ;;
      :2:*)
        # local/ours version of conflicted file
        printf 'line one\nline two\nlocal content\nline four\n'
        ;;
      :3:*)
        # remote/theirs version of conflicted file
        printf 'line one\nline two\nremote content\nline four\n'
        ;;
      *)
        printf 'commit abc1234567890\nAuthor: Test <test@example.com>\n\n    Initial commit\n'
        ;;
    esac
    ;;

  # ── config ────────────────────────────────────────────────────────────
  config)
    # config is used internally; silently succeed
    ;;

  # ── remote ────────────────────────────────────────────────────────────
  remote)
    printf 'origin\n'
    ;;

  # ── restore ───────────────────────────────────────────────────────────
  restore)
    if [ "$fail_cmd" = "restore" ]; then
      echo "error: restore failed" >&2
      exit 1
    fi
    ;;

  # ── clean ─────────────────────────────────────────────────────────────
  clean)
    if [ "$fail_cmd" = "clean" ]; then
      echo "error: clean failed" >&2
      exit 1
    fi
    ;;

  # ── Unknown command ───────────────────────────────────────────────────
  *)
    echo "git stub: unknown command '$subcmd'" >&2
    exit 1
    ;;
esac

exit 0
